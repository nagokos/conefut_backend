// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/nagokos/connefut_backend/ent/applicant"
	"github.com/nagokos/connefut_backend/ent/competition"
	"github.com/nagokos/connefut_backend/ent/predicate"
	"github.com/nagokos/connefut_backend/ent/prefecture"
	"github.com/nagokos/connefut_backend/ent/recruitment"
	"github.com/nagokos/connefut_backend/ent/recruitmenttag"
	"github.com/nagokos/connefut_backend/ent/stock"
	"github.com/nagokos/connefut_backend/ent/tag"
	"github.com/nagokos/connefut_backend/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplicant      = "Applicant"
	TypeCompetition    = "Competition"
	TypePrefecture     = "Prefecture"
	TypeRecruitment    = "Recruitment"
	TypeRecruitmentTag = "RecruitmentTag"
	TypeStock          = "Stock"
	TypeTag            = "Tag"
	TypeUser           = "User"
)

// ApplicantMutation represents an operation that mutates the Applicant nodes in the graph.
type ApplicantMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	management_status  *applicant.ManagementStatus
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	recruitment        *string
	clearedrecruitment bool
	done               bool
	oldValue           func(context.Context) (*Applicant, error)
	predicates         []predicate.Applicant
}

var _ ent.Mutation = (*ApplicantMutation)(nil)

// applicantOption allows management of the mutation configuration using functional options.
type applicantOption func(*ApplicantMutation)

// newApplicantMutation creates new mutation for the Applicant entity.
func newApplicantMutation(c config, op Op, opts ...applicantOption) *ApplicantMutation {
	m := &ApplicantMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicantID sets the ID field of the mutation.
func withApplicantID(id string) applicantOption {
	return func(m *ApplicantMutation) {
		var (
			err   error
			once  sync.Once
			value *Applicant
		)
		m.oldValue = func(ctx context.Context) (*Applicant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Applicant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicant sets the old Applicant of the mutation.
func withApplicant(node *Applicant) applicantOption {
	return func(m *ApplicantMutation) {
		m.oldValue = func(context.Context) (*Applicant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Applicant entities.
func (m *ApplicantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Applicant entity.
// If the Applicant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Applicant entity.
// If the Applicant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetManagementStatus sets the "management_status" field.
func (m *ApplicantMutation) SetManagementStatus(as applicant.ManagementStatus) {
	m.management_status = &as
}

// ManagementStatus returns the value of the "management_status" field in the mutation.
func (m *ApplicantMutation) ManagementStatus() (r applicant.ManagementStatus, exists bool) {
	v := m.management_status
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementStatus returns the old "management_status" field's value of the Applicant entity.
// If the Applicant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantMutation) OldManagementStatus(ctx context.Context) (v applicant.ManagementStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldManagementStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldManagementStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementStatus: %w", err)
	}
	return oldValue.ManagementStatus, nil
}

// ResetManagementStatus resets all changes to the "management_status" field.
func (m *ApplicantMutation) ResetManagementStatus() {
	m.management_status = nil
}

// SetUserID sets the "user_id" field.
func (m *ApplicantMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApplicantMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Applicant entity.
// If the Applicant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApplicantMutation) ResetUserID() {
	m.user = nil
}

// SetRecruitmentID sets the "recruitment_id" field.
func (m *ApplicantMutation) SetRecruitmentID(s string) {
	m.recruitment = &s
}

// RecruitmentID returns the value of the "recruitment_id" field in the mutation.
func (m *ApplicantMutation) RecruitmentID() (r string, exists bool) {
	v := m.recruitment
	if v == nil {
		return
	}
	return *v, true
}

// OldRecruitmentID returns the old "recruitment_id" field's value of the Applicant entity.
// If the Applicant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicantMutation) OldRecruitmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecruitmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecruitmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecruitmentID: %w", err)
	}
	return oldValue.RecruitmentID, nil
}

// ResetRecruitmentID resets all changes to the "recruitment_id" field.
func (m *ApplicantMutation) ResetRecruitmentID() {
	m.recruitment = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApplicantMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApplicantMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApplicantMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApplicantMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRecruitment clears the "recruitment" edge to the Recruitment entity.
func (m *ApplicantMutation) ClearRecruitment() {
	m.clearedrecruitment = true
}

// RecruitmentCleared reports if the "recruitment" edge to the Recruitment entity was cleared.
func (m *ApplicantMutation) RecruitmentCleared() bool {
	return m.clearedrecruitment
}

// RecruitmentIDs returns the "recruitment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecruitmentID instead. It exists only for internal usage by the builders.
func (m *ApplicantMutation) RecruitmentIDs() (ids []string) {
	if id := m.recruitment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecruitment resets all changes to the "recruitment" edge.
func (m *ApplicantMutation) ResetRecruitment() {
	m.recruitment = nil
	m.clearedrecruitment = false
}

// Where appends a list predicates to the ApplicantMutation builder.
func (m *ApplicantMutation) Where(ps ...predicate.Applicant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ApplicantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Applicant).
func (m *ApplicantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicantMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, applicant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, applicant.FieldUpdatedAt)
	}
	if m.management_status != nil {
		fields = append(fields, applicant.FieldManagementStatus)
	}
	if m.user != nil {
		fields = append(fields, applicant.FieldUserID)
	}
	if m.recruitment != nil {
		fields = append(fields, applicant.FieldRecruitmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applicant.FieldCreatedAt:
		return m.CreatedAt()
	case applicant.FieldUpdatedAt:
		return m.UpdatedAt()
	case applicant.FieldManagementStatus:
		return m.ManagementStatus()
	case applicant.FieldUserID:
		return m.UserID()
	case applicant.FieldRecruitmentID:
		return m.RecruitmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applicant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case applicant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case applicant.FieldManagementStatus:
		return m.OldManagementStatus(ctx)
	case applicant.FieldUserID:
		return m.OldUserID(ctx)
	case applicant.FieldRecruitmentID:
		return m.OldRecruitmentID(ctx)
	}
	return nil, fmt.Errorf("unknown Applicant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applicant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case applicant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case applicant.FieldManagementStatus:
		v, ok := value.(applicant.ManagementStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementStatus(v)
		return nil
	case applicant.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case applicant.FieldRecruitmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecruitmentID(v)
		return nil
	}
	return fmt.Errorf("unknown Applicant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Applicant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Applicant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicantMutation) ResetField(name string) error {
	switch name {
	case applicant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case applicant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case applicant.FieldManagementStatus:
		m.ResetManagementStatus()
		return nil
	case applicant.FieldUserID:
		m.ResetUserID()
		return nil
	case applicant.FieldRecruitmentID:
		m.ResetRecruitmentID()
		return nil
	}
	return fmt.Errorf("unknown Applicant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, applicant.EdgeUser)
	}
	if m.recruitment != nil {
		edges = append(edges, applicant.EdgeRecruitment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case applicant.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case applicant.EdgeRecruitment:
		if id := m.recruitment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, applicant.EdgeUser)
	}
	if m.clearedrecruitment {
		edges = append(edges, applicant.EdgeRecruitment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicantMutation) EdgeCleared(name string) bool {
	switch name {
	case applicant.EdgeUser:
		return m.cleareduser
	case applicant.EdgeRecruitment:
		return m.clearedrecruitment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicantMutation) ClearEdge(name string) error {
	switch name {
	case applicant.EdgeUser:
		m.ClearUser()
		return nil
	case applicant.EdgeRecruitment:
		m.ClearRecruitment()
		return nil
	}
	return fmt.Errorf("unknown Applicant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicantMutation) ResetEdge(name string) error {
	switch name {
	case applicant.EdgeUser:
		m.ResetUser()
		return nil
	case applicant.EdgeRecruitment:
		m.ResetRecruitment()
		return nil
	}
	return fmt.Errorf("unknown Applicant edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	clearedFields       map[string]struct{}
	recruitments        map[string]struct{}
	removedrecruitments map[string]struct{}
	clearedrecruitments bool
	done                bool
	oldValue            func(context.Context) (*Competition, error)
	predicates          []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id string) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competition entities.
func (m *CompetitionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CompetitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompetitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompetitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompetitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompetitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompetitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CompetitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompetitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompetitionMutation) ResetName() {
	m.name = nil
}

// AddRecruitmentIDs adds the "recruitments" edge to the Recruitment entity by ids.
func (m *CompetitionMutation) AddRecruitmentIDs(ids ...string) {
	if m.recruitments == nil {
		m.recruitments = make(map[string]struct{})
	}
	for i := range ids {
		m.recruitments[ids[i]] = struct{}{}
	}
}

// ClearRecruitments clears the "recruitments" edge to the Recruitment entity.
func (m *CompetitionMutation) ClearRecruitments() {
	m.clearedrecruitments = true
}

// RecruitmentsCleared reports if the "recruitments" edge to the Recruitment entity was cleared.
func (m *CompetitionMutation) RecruitmentsCleared() bool {
	return m.clearedrecruitments
}

// RemoveRecruitmentIDs removes the "recruitments" edge to the Recruitment entity by IDs.
func (m *CompetitionMutation) RemoveRecruitmentIDs(ids ...string) {
	if m.removedrecruitments == nil {
		m.removedrecruitments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.recruitments, ids[i])
		m.removedrecruitments[ids[i]] = struct{}{}
	}
}

// RemovedRecruitments returns the removed IDs of the "recruitments" edge to the Recruitment entity.
func (m *CompetitionMutation) RemovedRecruitmentsIDs() (ids []string) {
	for id := range m.removedrecruitments {
		ids = append(ids, id)
	}
	return
}

// RecruitmentsIDs returns the "recruitments" edge IDs in the mutation.
func (m *CompetitionMutation) RecruitmentsIDs() (ids []string) {
	for id := range m.recruitments {
		ids = append(ids, id)
	}
	return
}

// ResetRecruitments resets all changes to the "recruitments" edge.
func (m *CompetitionMutation) ResetRecruitments() {
	m.recruitments = nil
	m.clearedrecruitments = false
	m.removedrecruitments = nil
}

// Where appends a list predicates to the CompetitionMutation builder.
func (m *CompetitionMutation) Where(ps ...predicate.Competition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, competition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, competition.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, competition.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldCreatedAt:
		return m.CreatedAt()
	case competition.FieldUpdatedAt:
		return m.UpdatedAt()
	case competition.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case competition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case competition.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case competition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case competition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case competition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case competition.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recruitments != nil {
		edges = append(edges, competition.EdgeRecruitments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeRecruitments:
		ids := make([]ent.Value, 0, len(m.recruitments))
		for id := range m.recruitments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecruitments != nil {
		edges = append(edges, competition.EdgeRecruitments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeRecruitments:
		ids := make([]ent.Value, 0, len(m.removedrecruitments))
		for id := range m.removedrecruitments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecruitments {
		edges = append(edges, competition.EdgeRecruitments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeRecruitments:
		return m.clearedrecruitments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeRecruitments:
		m.ResetRecruitments()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// PrefectureMutation represents an operation that mutates the Prefecture nodes in the graph.
type PrefectureMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	clearedFields       map[string]struct{}
	recruitments        map[string]struct{}
	removedrecruitments map[string]struct{}
	clearedrecruitments bool
	done                bool
	oldValue            func(context.Context) (*Prefecture, error)
	predicates          []predicate.Prefecture
}

var _ ent.Mutation = (*PrefectureMutation)(nil)

// prefectureOption allows management of the mutation configuration using functional options.
type prefectureOption func(*PrefectureMutation)

// newPrefectureMutation creates new mutation for the Prefecture entity.
func newPrefectureMutation(c config, op Op, opts ...prefectureOption) *PrefectureMutation {
	m := &PrefectureMutation{
		config:        c,
		op:            op,
		typ:           TypePrefecture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrefectureID sets the ID field of the mutation.
func withPrefectureID(id string) prefectureOption {
	return func(m *PrefectureMutation) {
		var (
			err   error
			once  sync.Once
			value *Prefecture
		)
		m.oldValue = func(ctx context.Context) (*Prefecture, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prefecture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrefecture sets the old Prefecture of the mutation.
func withPrefecture(node *Prefecture) prefectureOption {
	return func(m *PrefectureMutation) {
		m.oldValue = func(context.Context) (*Prefecture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrefectureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrefectureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Prefecture entities.
func (m *PrefectureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrefectureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *PrefectureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PrefectureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Prefecture entity.
// If the Prefecture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrefectureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PrefectureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PrefectureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PrefectureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Prefecture entity.
// If the Prefecture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrefectureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PrefectureMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PrefectureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PrefectureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Prefecture entity.
// If the Prefecture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrefectureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PrefectureMutation) ResetName() {
	m.name = nil
}

// AddRecruitmentIDs adds the "recruitments" edge to the Recruitment entity by ids.
func (m *PrefectureMutation) AddRecruitmentIDs(ids ...string) {
	if m.recruitments == nil {
		m.recruitments = make(map[string]struct{})
	}
	for i := range ids {
		m.recruitments[ids[i]] = struct{}{}
	}
}

// ClearRecruitments clears the "recruitments" edge to the Recruitment entity.
func (m *PrefectureMutation) ClearRecruitments() {
	m.clearedrecruitments = true
}

// RecruitmentsCleared reports if the "recruitments" edge to the Recruitment entity was cleared.
func (m *PrefectureMutation) RecruitmentsCleared() bool {
	return m.clearedrecruitments
}

// RemoveRecruitmentIDs removes the "recruitments" edge to the Recruitment entity by IDs.
func (m *PrefectureMutation) RemoveRecruitmentIDs(ids ...string) {
	if m.removedrecruitments == nil {
		m.removedrecruitments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.recruitments, ids[i])
		m.removedrecruitments[ids[i]] = struct{}{}
	}
}

// RemovedRecruitments returns the removed IDs of the "recruitments" edge to the Recruitment entity.
func (m *PrefectureMutation) RemovedRecruitmentsIDs() (ids []string) {
	for id := range m.removedrecruitments {
		ids = append(ids, id)
	}
	return
}

// RecruitmentsIDs returns the "recruitments" edge IDs in the mutation.
func (m *PrefectureMutation) RecruitmentsIDs() (ids []string) {
	for id := range m.recruitments {
		ids = append(ids, id)
	}
	return
}

// ResetRecruitments resets all changes to the "recruitments" edge.
func (m *PrefectureMutation) ResetRecruitments() {
	m.recruitments = nil
	m.clearedrecruitments = false
	m.removedrecruitments = nil
}

// Where appends a list predicates to the PrefectureMutation builder.
func (m *PrefectureMutation) Where(ps ...predicate.Prefecture) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PrefectureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prefecture).
func (m *PrefectureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrefectureMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, prefecture.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, prefecture.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, prefecture.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrefectureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prefecture.FieldCreatedAt:
		return m.CreatedAt()
	case prefecture.FieldUpdatedAt:
		return m.UpdatedAt()
	case prefecture.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrefectureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prefecture.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case prefecture.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case prefecture.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Prefecture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrefectureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prefecture.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case prefecture.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case prefecture.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Prefecture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrefectureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrefectureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrefectureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefecture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrefectureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrefectureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrefectureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prefecture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrefectureMutation) ResetField(name string) error {
	switch name {
	case prefecture.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case prefecture.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case prefecture.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Prefecture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrefectureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recruitments != nil {
		edges = append(edges, prefecture.EdgeRecruitments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrefectureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prefecture.EdgeRecruitments:
		ids := make([]ent.Value, 0, len(m.recruitments))
		for id := range m.recruitments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrefectureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecruitments != nil {
		edges = append(edges, prefecture.EdgeRecruitments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrefectureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prefecture.EdgeRecruitments:
		ids := make([]ent.Value, 0, len(m.removedrecruitments))
		for id := range m.removedrecruitments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrefectureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecruitments {
		edges = append(edges, prefecture.EdgeRecruitments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrefectureMutation) EdgeCleared(name string) bool {
	switch name {
	case prefecture.EdgeRecruitments:
		return m.clearedrecruitments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrefectureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefecture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrefectureMutation) ResetEdge(name string) error {
	switch name {
	case prefecture.EdgeRecruitments:
		m.ResetRecruitments()
		return nil
	}
	return fmt.Errorf("unknown Prefecture edge %s", name)
}

// RecruitmentMutation represents an operation that mutates the Recruitment nodes in the graph.
type RecruitmentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *time.Time
	updated_at              *time.Time
	title                   *string
	_type                   *recruitment.Type
	place                   *string
	start_at                *time.Time
	content                 *string
	locationLat             *float64
	addlocationLat          *float64
	locationLng             *float64
	addlocationLng          *float64
	capacity                *int
	addcapacity             *int
	closing_at              *time.Time
	status                  *recruitment.Status
	clearedFields           map[string]struct{}
	stocks                  map[string]struct{}
	removedstocks           map[string]struct{}
	clearedstocks           bool
	applicants              map[string]struct{}
	removedapplicants       map[string]struct{}
	clearedapplicants       bool
	recruitment_tags        map[string]struct{}
	removedrecruitment_tags map[string]struct{}
	clearedrecruitment_tags bool
	user                    *string
	cleareduser             bool
	prefecture              *string
	clearedprefecture       bool
	competition             *string
	clearedcompetition      bool
	done                    bool
	oldValue                func(context.Context) (*Recruitment, error)
	predicates              []predicate.Recruitment
}

var _ ent.Mutation = (*RecruitmentMutation)(nil)

// recruitmentOption allows management of the mutation configuration using functional options.
type recruitmentOption func(*RecruitmentMutation)

// newRecruitmentMutation creates new mutation for the Recruitment entity.
func newRecruitmentMutation(c config, op Op, opts ...recruitmentOption) *RecruitmentMutation {
	m := &RecruitmentMutation{
		config:        c,
		op:            op,
		typ:           TypeRecruitment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecruitmentID sets the ID field of the mutation.
func withRecruitmentID(id string) recruitmentOption {
	return func(m *RecruitmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Recruitment
		)
		m.oldValue = func(ctx context.Context) (*Recruitment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Recruitment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecruitment sets the old Recruitment of the mutation.
func withRecruitment(node *Recruitment) recruitmentOption {
	return func(m *RecruitmentMutation) {
		m.oldValue = func(context.Context) (*Recruitment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecruitmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecruitmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Recruitment entities.
func (m *RecruitmentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecruitmentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *RecruitmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecruitmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecruitmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecruitmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecruitmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecruitmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *RecruitmentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RecruitmentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RecruitmentMutation) ResetTitle() {
	m.title = nil
}

// SetType sets the "type" field.
func (m *RecruitmentMutation) SetType(r recruitment.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RecruitmentMutation) GetType() (r recruitment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldType(ctx context.Context) (v recruitment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RecruitmentMutation) ResetType() {
	m._type = nil
}

// SetPlace sets the "place" field.
func (m *RecruitmentMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *RecruitmentMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ClearPlace clears the value of the "place" field.
func (m *RecruitmentMutation) ClearPlace() {
	m.place = nil
	m.clearedFields[recruitment.FieldPlace] = struct{}{}
}

// PlaceCleared returns if the "place" field was cleared in this mutation.
func (m *RecruitmentMutation) PlaceCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldPlace]
	return ok
}

// ResetPlace resets all changes to the "place" field.
func (m *RecruitmentMutation) ResetPlace() {
	m.place = nil
	delete(m.clearedFields, recruitment.FieldPlace)
}

// SetStartAt sets the "start_at" field.
func (m *RecruitmentMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *RecruitmentMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *RecruitmentMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[recruitment.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *RecruitmentMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *RecruitmentMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, recruitment.FieldStartAt)
}

// SetContent sets the "content" field.
func (m *RecruitmentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *RecruitmentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *RecruitmentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[recruitment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *RecruitmentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *RecruitmentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, recruitment.FieldContent)
}

// SetLocationLat sets the "locationLat" field.
func (m *RecruitmentMutation) SetLocationLat(f float64) {
	m.locationLat = &f
	m.addlocationLat = nil
}

// LocationLat returns the value of the "locationLat" field in the mutation.
func (m *RecruitmentMutation) LocationLat() (r float64, exists bool) {
	v := m.locationLat
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLat returns the old "locationLat" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldLocationLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocationLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocationLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLat: %w", err)
	}
	return oldValue.LocationLat, nil
}

// AddLocationLat adds f to the "locationLat" field.
func (m *RecruitmentMutation) AddLocationLat(f float64) {
	if m.addlocationLat != nil {
		*m.addlocationLat += f
	} else {
		m.addlocationLat = &f
	}
}

// AddedLocationLat returns the value that was added to the "locationLat" field in this mutation.
func (m *RecruitmentMutation) AddedLocationLat() (r float64, exists bool) {
	v := m.addlocationLat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationLat clears the value of the "locationLat" field.
func (m *RecruitmentMutation) ClearLocationLat() {
	m.locationLat = nil
	m.addlocationLat = nil
	m.clearedFields[recruitment.FieldLocationLat] = struct{}{}
}

// LocationLatCleared returns if the "locationLat" field was cleared in this mutation.
func (m *RecruitmentMutation) LocationLatCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldLocationLat]
	return ok
}

// ResetLocationLat resets all changes to the "locationLat" field.
func (m *RecruitmentMutation) ResetLocationLat() {
	m.locationLat = nil
	m.addlocationLat = nil
	delete(m.clearedFields, recruitment.FieldLocationLat)
}

// SetLocationLng sets the "locationLng" field.
func (m *RecruitmentMutation) SetLocationLng(f float64) {
	m.locationLng = &f
	m.addlocationLng = nil
}

// LocationLng returns the value of the "locationLng" field in the mutation.
func (m *RecruitmentMutation) LocationLng() (r float64, exists bool) {
	v := m.locationLng
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationLng returns the old "locationLng" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldLocationLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocationLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocationLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationLng: %w", err)
	}
	return oldValue.LocationLng, nil
}

// AddLocationLng adds f to the "locationLng" field.
func (m *RecruitmentMutation) AddLocationLng(f float64) {
	if m.addlocationLng != nil {
		*m.addlocationLng += f
	} else {
		m.addlocationLng = &f
	}
}

// AddedLocationLng returns the value that was added to the "locationLng" field in this mutation.
func (m *RecruitmentMutation) AddedLocationLng() (r float64, exists bool) {
	v := m.addlocationLng
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationLng clears the value of the "locationLng" field.
func (m *RecruitmentMutation) ClearLocationLng() {
	m.locationLng = nil
	m.addlocationLng = nil
	m.clearedFields[recruitment.FieldLocationLng] = struct{}{}
}

// LocationLngCleared returns if the "locationLng" field was cleared in this mutation.
func (m *RecruitmentMutation) LocationLngCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldLocationLng]
	return ok
}

// ResetLocationLng resets all changes to the "locationLng" field.
func (m *RecruitmentMutation) ResetLocationLng() {
	m.locationLng = nil
	m.addlocationLng = nil
	delete(m.clearedFields, recruitment.FieldLocationLng)
}

// SetCapacity sets the "capacity" field.
func (m *RecruitmentMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *RecruitmentMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *RecruitmentMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *RecruitmentMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of the "capacity" field.
func (m *RecruitmentMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[recruitment.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *RecruitmentMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *RecruitmentMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, recruitment.FieldCapacity)
}

// SetClosingAt sets the "closing_at" field.
func (m *RecruitmentMutation) SetClosingAt(t time.Time) {
	m.closing_at = &t
}

// ClosingAt returns the value of the "closing_at" field in the mutation.
func (m *RecruitmentMutation) ClosingAt() (r time.Time, exists bool) {
	v := m.closing_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosingAt returns the old "closing_at" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldClosingAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosingAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosingAt: %w", err)
	}
	return oldValue.ClosingAt, nil
}

// ClearClosingAt clears the value of the "closing_at" field.
func (m *RecruitmentMutation) ClearClosingAt() {
	m.closing_at = nil
	m.clearedFields[recruitment.FieldClosingAt] = struct{}{}
}

// ClosingAtCleared returns if the "closing_at" field was cleared in this mutation.
func (m *RecruitmentMutation) ClosingAtCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldClosingAt]
	return ok
}

// ResetClosingAt resets all changes to the "closing_at" field.
func (m *RecruitmentMutation) ResetClosingAt() {
	m.closing_at = nil
	delete(m.clearedFields, recruitment.FieldClosingAt)
}

// SetStatus sets the "status" field.
func (m *RecruitmentMutation) SetStatus(r recruitment.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RecruitmentMutation) Status() (r recruitment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldStatus(ctx context.Context) (v recruitment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RecruitmentMutation) ResetStatus() {
	m.status = nil
}

// SetPrefectureID sets the "prefecture_id" field.
func (m *RecruitmentMutation) SetPrefectureID(s string) {
	m.prefecture = &s
}

// PrefectureID returns the value of the "prefecture_id" field in the mutation.
func (m *RecruitmentMutation) PrefectureID() (r string, exists bool) {
	v := m.prefecture
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefectureID returns the old "prefecture_id" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldPrefectureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrefectureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrefectureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefectureID: %w", err)
	}
	return oldValue.PrefectureID, nil
}

// ClearPrefectureID clears the value of the "prefecture_id" field.
func (m *RecruitmentMutation) ClearPrefectureID() {
	m.prefecture = nil
	m.clearedFields[recruitment.FieldPrefectureID] = struct{}{}
}

// PrefectureIDCleared returns if the "prefecture_id" field was cleared in this mutation.
func (m *RecruitmentMutation) PrefectureIDCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldPrefectureID]
	return ok
}

// ResetPrefectureID resets all changes to the "prefecture_id" field.
func (m *RecruitmentMutation) ResetPrefectureID() {
	m.prefecture = nil
	delete(m.clearedFields, recruitment.FieldPrefectureID)
}

// SetCompetitionID sets the "competition_id" field.
func (m *RecruitmentMutation) SetCompetitionID(s string) {
	m.competition = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *RecruitmentMutation) CompetitionID() (r string, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ClearCompetitionID clears the value of the "competition_id" field.
func (m *RecruitmentMutation) ClearCompetitionID() {
	m.competition = nil
	m.clearedFields[recruitment.FieldCompetitionID] = struct{}{}
}

// CompetitionIDCleared returns if the "competition_id" field was cleared in this mutation.
func (m *RecruitmentMutation) CompetitionIDCleared() bool {
	_, ok := m.clearedFields[recruitment.FieldCompetitionID]
	return ok
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *RecruitmentMutation) ResetCompetitionID() {
	m.competition = nil
	delete(m.clearedFields, recruitment.FieldCompetitionID)
}

// SetUserID sets the "user_id" field.
func (m *RecruitmentMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RecruitmentMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Recruitment entity.
// If the Recruitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RecruitmentMutation) ResetUserID() {
	m.user = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *RecruitmentMutation) AddStockIDs(ids ...string) {
	if m.stocks == nil {
		m.stocks = make(map[string]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *RecruitmentMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *RecruitmentMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *RecruitmentMutation) RemoveStockIDs(ids ...string) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *RecruitmentMutation) RemovedStocksIDs() (ids []string) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *RecruitmentMutation) StocksIDs() (ids []string) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *RecruitmentMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddApplicantIDs adds the "applicants" edge to the Applicant entity by ids.
func (m *RecruitmentMutation) AddApplicantIDs(ids ...string) {
	if m.applicants == nil {
		m.applicants = make(map[string]struct{})
	}
	for i := range ids {
		m.applicants[ids[i]] = struct{}{}
	}
}

// ClearApplicants clears the "applicants" edge to the Applicant entity.
func (m *RecruitmentMutation) ClearApplicants() {
	m.clearedapplicants = true
}

// ApplicantsCleared reports if the "applicants" edge to the Applicant entity was cleared.
func (m *RecruitmentMutation) ApplicantsCleared() bool {
	return m.clearedapplicants
}

// RemoveApplicantIDs removes the "applicants" edge to the Applicant entity by IDs.
func (m *RecruitmentMutation) RemoveApplicantIDs(ids ...string) {
	if m.removedapplicants == nil {
		m.removedapplicants = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.applicants, ids[i])
		m.removedapplicants[ids[i]] = struct{}{}
	}
}

// RemovedApplicants returns the removed IDs of the "applicants" edge to the Applicant entity.
func (m *RecruitmentMutation) RemovedApplicantsIDs() (ids []string) {
	for id := range m.removedapplicants {
		ids = append(ids, id)
	}
	return
}

// ApplicantsIDs returns the "applicants" edge IDs in the mutation.
func (m *RecruitmentMutation) ApplicantsIDs() (ids []string) {
	for id := range m.applicants {
		ids = append(ids, id)
	}
	return
}

// ResetApplicants resets all changes to the "applicants" edge.
func (m *RecruitmentMutation) ResetApplicants() {
	m.applicants = nil
	m.clearedapplicants = false
	m.removedapplicants = nil
}

// AddRecruitmentTagIDs adds the "recruitment_tags" edge to the RecruitmentTag entity by ids.
func (m *RecruitmentMutation) AddRecruitmentTagIDs(ids ...string) {
	if m.recruitment_tags == nil {
		m.recruitment_tags = make(map[string]struct{})
	}
	for i := range ids {
		m.recruitment_tags[ids[i]] = struct{}{}
	}
}

// ClearRecruitmentTags clears the "recruitment_tags" edge to the RecruitmentTag entity.
func (m *RecruitmentMutation) ClearRecruitmentTags() {
	m.clearedrecruitment_tags = true
}

// RecruitmentTagsCleared reports if the "recruitment_tags" edge to the RecruitmentTag entity was cleared.
func (m *RecruitmentMutation) RecruitmentTagsCleared() bool {
	return m.clearedrecruitment_tags
}

// RemoveRecruitmentTagIDs removes the "recruitment_tags" edge to the RecruitmentTag entity by IDs.
func (m *RecruitmentMutation) RemoveRecruitmentTagIDs(ids ...string) {
	if m.removedrecruitment_tags == nil {
		m.removedrecruitment_tags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.recruitment_tags, ids[i])
		m.removedrecruitment_tags[ids[i]] = struct{}{}
	}
}

// RemovedRecruitmentTags returns the removed IDs of the "recruitment_tags" edge to the RecruitmentTag entity.
func (m *RecruitmentMutation) RemovedRecruitmentTagsIDs() (ids []string) {
	for id := range m.removedrecruitment_tags {
		ids = append(ids, id)
	}
	return
}

// RecruitmentTagsIDs returns the "recruitment_tags" edge IDs in the mutation.
func (m *RecruitmentMutation) RecruitmentTagsIDs() (ids []string) {
	for id := range m.recruitment_tags {
		ids = append(ids, id)
	}
	return
}

// ResetRecruitmentTags resets all changes to the "recruitment_tags" edge.
func (m *RecruitmentMutation) ResetRecruitmentTags() {
	m.recruitment_tags = nil
	m.clearedrecruitment_tags = false
	m.removedrecruitment_tags = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RecruitmentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RecruitmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RecruitmentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RecruitmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPrefecture clears the "prefecture" edge to the Prefecture entity.
func (m *RecruitmentMutation) ClearPrefecture() {
	m.clearedprefecture = true
}

// PrefectureCleared reports if the "prefecture" edge to the Prefecture entity was cleared.
func (m *RecruitmentMutation) PrefectureCleared() bool {
	return m.PrefectureIDCleared() || m.clearedprefecture
}

// PrefectureIDs returns the "prefecture" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrefectureID instead. It exists only for internal usage by the builders.
func (m *RecruitmentMutation) PrefectureIDs() (ids []string) {
	if id := m.prefecture; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrefecture resets all changes to the "prefecture" edge.
func (m *RecruitmentMutation) ResetPrefecture() {
	m.prefecture = nil
	m.clearedprefecture = false
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *RecruitmentMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *RecruitmentMutation) CompetitionCleared() bool {
	return m.CompetitionIDCleared() || m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *RecruitmentMutation) CompetitionIDs() (ids []string) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *RecruitmentMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// Where appends a list predicates to the RecruitmentMutation builder.
func (m *RecruitmentMutation) Where(ps ...predicate.Recruitment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RecruitmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Recruitment).
func (m *RecruitmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecruitmentMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, recruitment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recruitment.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, recruitment.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, recruitment.FieldType)
	}
	if m.place != nil {
		fields = append(fields, recruitment.FieldPlace)
	}
	if m.start_at != nil {
		fields = append(fields, recruitment.FieldStartAt)
	}
	if m.content != nil {
		fields = append(fields, recruitment.FieldContent)
	}
	if m.locationLat != nil {
		fields = append(fields, recruitment.FieldLocationLat)
	}
	if m.locationLng != nil {
		fields = append(fields, recruitment.FieldLocationLng)
	}
	if m.capacity != nil {
		fields = append(fields, recruitment.FieldCapacity)
	}
	if m.closing_at != nil {
		fields = append(fields, recruitment.FieldClosingAt)
	}
	if m.status != nil {
		fields = append(fields, recruitment.FieldStatus)
	}
	if m.prefecture != nil {
		fields = append(fields, recruitment.FieldPrefectureID)
	}
	if m.competition != nil {
		fields = append(fields, recruitment.FieldCompetitionID)
	}
	if m.user != nil {
		fields = append(fields, recruitment.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecruitmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recruitment.FieldCreatedAt:
		return m.CreatedAt()
	case recruitment.FieldUpdatedAt:
		return m.UpdatedAt()
	case recruitment.FieldTitle:
		return m.Title()
	case recruitment.FieldType:
		return m.GetType()
	case recruitment.FieldPlace:
		return m.Place()
	case recruitment.FieldStartAt:
		return m.StartAt()
	case recruitment.FieldContent:
		return m.Content()
	case recruitment.FieldLocationLat:
		return m.LocationLat()
	case recruitment.FieldLocationLng:
		return m.LocationLng()
	case recruitment.FieldCapacity:
		return m.Capacity()
	case recruitment.FieldClosingAt:
		return m.ClosingAt()
	case recruitment.FieldStatus:
		return m.Status()
	case recruitment.FieldPrefectureID:
		return m.PrefectureID()
	case recruitment.FieldCompetitionID:
		return m.CompetitionID()
	case recruitment.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecruitmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recruitment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recruitment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recruitment.FieldTitle:
		return m.OldTitle(ctx)
	case recruitment.FieldType:
		return m.OldType(ctx)
	case recruitment.FieldPlace:
		return m.OldPlace(ctx)
	case recruitment.FieldStartAt:
		return m.OldStartAt(ctx)
	case recruitment.FieldContent:
		return m.OldContent(ctx)
	case recruitment.FieldLocationLat:
		return m.OldLocationLat(ctx)
	case recruitment.FieldLocationLng:
		return m.OldLocationLng(ctx)
	case recruitment.FieldCapacity:
		return m.OldCapacity(ctx)
	case recruitment.FieldClosingAt:
		return m.OldClosingAt(ctx)
	case recruitment.FieldStatus:
		return m.OldStatus(ctx)
	case recruitment.FieldPrefectureID:
		return m.OldPrefectureID(ctx)
	case recruitment.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case recruitment.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Recruitment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecruitmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recruitment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recruitment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recruitment.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case recruitment.FieldType:
		v, ok := value.(recruitment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case recruitment.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case recruitment.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case recruitment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case recruitment.FieldLocationLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLat(v)
		return nil
	case recruitment.FieldLocationLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationLng(v)
		return nil
	case recruitment.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case recruitment.FieldClosingAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosingAt(v)
		return nil
	case recruitment.FieldStatus:
		v, ok := value.(recruitment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case recruitment.FieldPrefectureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefectureID(v)
		return nil
	case recruitment.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case recruitment.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Recruitment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecruitmentMutation) AddedFields() []string {
	var fields []string
	if m.addlocationLat != nil {
		fields = append(fields, recruitment.FieldLocationLat)
	}
	if m.addlocationLng != nil {
		fields = append(fields, recruitment.FieldLocationLng)
	}
	if m.addcapacity != nil {
		fields = append(fields, recruitment.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecruitmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recruitment.FieldLocationLat:
		return m.AddedLocationLat()
	case recruitment.FieldLocationLng:
		return m.AddedLocationLng()
	case recruitment.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecruitmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recruitment.FieldLocationLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLat(v)
		return nil
	case recruitment.FieldLocationLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationLng(v)
		return nil
	case recruitment.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Recruitment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecruitmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recruitment.FieldPlace) {
		fields = append(fields, recruitment.FieldPlace)
	}
	if m.FieldCleared(recruitment.FieldStartAt) {
		fields = append(fields, recruitment.FieldStartAt)
	}
	if m.FieldCleared(recruitment.FieldContent) {
		fields = append(fields, recruitment.FieldContent)
	}
	if m.FieldCleared(recruitment.FieldLocationLat) {
		fields = append(fields, recruitment.FieldLocationLat)
	}
	if m.FieldCleared(recruitment.FieldLocationLng) {
		fields = append(fields, recruitment.FieldLocationLng)
	}
	if m.FieldCleared(recruitment.FieldCapacity) {
		fields = append(fields, recruitment.FieldCapacity)
	}
	if m.FieldCleared(recruitment.FieldClosingAt) {
		fields = append(fields, recruitment.FieldClosingAt)
	}
	if m.FieldCleared(recruitment.FieldPrefectureID) {
		fields = append(fields, recruitment.FieldPrefectureID)
	}
	if m.FieldCleared(recruitment.FieldCompetitionID) {
		fields = append(fields, recruitment.FieldCompetitionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecruitmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecruitmentMutation) ClearField(name string) error {
	switch name {
	case recruitment.FieldPlace:
		m.ClearPlace()
		return nil
	case recruitment.FieldStartAt:
		m.ClearStartAt()
		return nil
	case recruitment.FieldContent:
		m.ClearContent()
		return nil
	case recruitment.FieldLocationLat:
		m.ClearLocationLat()
		return nil
	case recruitment.FieldLocationLng:
		m.ClearLocationLng()
		return nil
	case recruitment.FieldCapacity:
		m.ClearCapacity()
		return nil
	case recruitment.FieldClosingAt:
		m.ClearClosingAt()
		return nil
	case recruitment.FieldPrefectureID:
		m.ClearPrefectureID()
		return nil
	case recruitment.FieldCompetitionID:
		m.ClearCompetitionID()
		return nil
	}
	return fmt.Errorf("unknown Recruitment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecruitmentMutation) ResetField(name string) error {
	switch name {
	case recruitment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recruitment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recruitment.FieldTitle:
		m.ResetTitle()
		return nil
	case recruitment.FieldType:
		m.ResetType()
		return nil
	case recruitment.FieldPlace:
		m.ResetPlace()
		return nil
	case recruitment.FieldStartAt:
		m.ResetStartAt()
		return nil
	case recruitment.FieldContent:
		m.ResetContent()
		return nil
	case recruitment.FieldLocationLat:
		m.ResetLocationLat()
		return nil
	case recruitment.FieldLocationLng:
		m.ResetLocationLng()
		return nil
	case recruitment.FieldCapacity:
		m.ResetCapacity()
		return nil
	case recruitment.FieldClosingAt:
		m.ResetClosingAt()
		return nil
	case recruitment.FieldStatus:
		m.ResetStatus()
		return nil
	case recruitment.FieldPrefectureID:
		m.ResetPrefectureID()
		return nil
	case recruitment.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case recruitment.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Recruitment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecruitmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.stocks != nil {
		edges = append(edges, recruitment.EdgeStocks)
	}
	if m.applicants != nil {
		edges = append(edges, recruitment.EdgeApplicants)
	}
	if m.recruitment_tags != nil {
		edges = append(edges, recruitment.EdgeRecruitmentTags)
	}
	if m.user != nil {
		edges = append(edges, recruitment.EdgeUser)
	}
	if m.prefecture != nil {
		edges = append(edges, recruitment.EdgePrefecture)
	}
	if m.competition != nil {
		edges = append(edges, recruitment.EdgeCompetition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecruitmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recruitment.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case recruitment.EdgeApplicants:
		ids := make([]ent.Value, 0, len(m.applicants))
		for id := range m.applicants {
			ids = append(ids, id)
		}
		return ids
	case recruitment.EdgeRecruitmentTags:
		ids := make([]ent.Value, 0, len(m.recruitment_tags))
		for id := range m.recruitment_tags {
			ids = append(ids, id)
		}
		return ids
	case recruitment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case recruitment.EdgePrefecture:
		if id := m.prefecture; id != nil {
			return []ent.Value{*id}
		}
	case recruitment.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecruitmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedstocks != nil {
		edges = append(edges, recruitment.EdgeStocks)
	}
	if m.removedapplicants != nil {
		edges = append(edges, recruitment.EdgeApplicants)
	}
	if m.removedrecruitment_tags != nil {
		edges = append(edges, recruitment.EdgeRecruitmentTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecruitmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case recruitment.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case recruitment.EdgeApplicants:
		ids := make([]ent.Value, 0, len(m.removedapplicants))
		for id := range m.removedapplicants {
			ids = append(ids, id)
		}
		return ids
	case recruitment.EdgeRecruitmentTags:
		ids := make([]ent.Value, 0, len(m.removedrecruitment_tags))
		for id := range m.removedrecruitment_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecruitmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedstocks {
		edges = append(edges, recruitment.EdgeStocks)
	}
	if m.clearedapplicants {
		edges = append(edges, recruitment.EdgeApplicants)
	}
	if m.clearedrecruitment_tags {
		edges = append(edges, recruitment.EdgeRecruitmentTags)
	}
	if m.cleareduser {
		edges = append(edges, recruitment.EdgeUser)
	}
	if m.clearedprefecture {
		edges = append(edges, recruitment.EdgePrefecture)
	}
	if m.clearedcompetition {
		edges = append(edges, recruitment.EdgeCompetition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecruitmentMutation) EdgeCleared(name string) bool {
	switch name {
	case recruitment.EdgeStocks:
		return m.clearedstocks
	case recruitment.EdgeApplicants:
		return m.clearedapplicants
	case recruitment.EdgeRecruitmentTags:
		return m.clearedrecruitment_tags
	case recruitment.EdgeUser:
		return m.cleareduser
	case recruitment.EdgePrefecture:
		return m.clearedprefecture
	case recruitment.EdgeCompetition:
		return m.clearedcompetition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecruitmentMutation) ClearEdge(name string) error {
	switch name {
	case recruitment.EdgeUser:
		m.ClearUser()
		return nil
	case recruitment.EdgePrefecture:
		m.ClearPrefecture()
		return nil
	case recruitment.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Recruitment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecruitmentMutation) ResetEdge(name string) error {
	switch name {
	case recruitment.EdgeStocks:
		m.ResetStocks()
		return nil
	case recruitment.EdgeApplicants:
		m.ResetApplicants()
		return nil
	case recruitment.EdgeRecruitmentTags:
		m.ResetRecruitmentTags()
		return nil
	case recruitment.EdgeUser:
		m.ResetUser()
		return nil
	case recruitment.EdgePrefecture:
		m.ResetPrefecture()
		return nil
	case recruitment.EdgeCompetition:
		m.ResetCompetition()
		return nil
	}
	return fmt.Errorf("unknown Recruitment edge %s", name)
}

// RecruitmentTagMutation represents an operation that mutates the RecruitmentTag nodes in the graph.
type RecruitmentTagMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	recruitment        *string
	clearedrecruitment bool
	tag                *string
	clearedtag         bool
	done               bool
	oldValue           func(context.Context) (*RecruitmentTag, error)
	predicates         []predicate.RecruitmentTag
}

var _ ent.Mutation = (*RecruitmentTagMutation)(nil)

// recruitmenttagOption allows management of the mutation configuration using functional options.
type recruitmenttagOption func(*RecruitmentTagMutation)

// newRecruitmentTagMutation creates new mutation for the RecruitmentTag entity.
func newRecruitmentTagMutation(c config, op Op, opts ...recruitmenttagOption) *RecruitmentTagMutation {
	m := &RecruitmentTagMutation{
		config:        c,
		op:            op,
		typ:           TypeRecruitmentTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecruitmentTagID sets the ID field of the mutation.
func withRecruitmentTagID(id string) recruitmenttagOption {
	return func(m *RecruitmentTagMutation) {
		var (
			err   error
			once  sync.Once
			value *RecruitmentTag
		)
		m.oldValue = func(ctx context.Context) (*RecruitmentTag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecruitmentTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecruitmentTag sets the old RecruitmentTag of the mutation.
func withRecruitmentTag(node *RecruitmentTag) recruitmenttagOption {
	return func(m *RecruitmentTagMutation) {
		m.oldValue = func(context.Context) (*RecruitmentTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecruitmentTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecruitmentTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RecruitmentTag entities.
func (m *RecruitmentTagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecruitmentTagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *RecruitmentTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecruitmentTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecruitmentTag entity.
// If the RecruitmentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecruitmentTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecruitmentTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecruitmentTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RecruitmentTag entity.
// If the RecruitmentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecruitmentTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRecruitmentID sets the "recruitment_id" field.
func (m *RecruitmentTagMutation) SetRecruitmentID(s string) {
	m.recruitment = &s
}

// RecruitmentID returns the value of the "recruitment_id" field in the mutation.
func (m *RecruitmentTagMutation) RecruitmentID() (r string, exists bool) {
	v := m.recruitment
	if v == nil {
		return
	}
	return *v, true
}

// OldRecruitmentID returns the old "recruitment_id" field's value of the RecruitmentTag entity.
// If the RecruitmentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentTagMutation) OldRecruitmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecruitmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecruitmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecruitmentID: %w", err)
	}
	return oldValue.RecruitmentID, nil
}

// ResetRecruitmentID resets all changes to the "recruitment_id" field.
func (m *RecruitmentTagMutation) ResetRecruitmentID() {
	m.recruitment = nil
}

// SetTagID sets the "tag_id" field.
func (m *RecruitmentTagMutation) SetTagID(s string) {
	m.tag = &s
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *RecruitmentTagMutation) TagID() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the RecruitmentTag entity.
// If the RecruitmentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecruitmentTagMutation) OldTagID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *RecruitmentTagMutation) ResetTagID() {
	m.tag = nil
}

// ClearRecruitment clears the "recruitment" edge to the Recruitment entity.
func (m *RecruitmentTagMutation) ClearRecruitment() {
	m.clearedrecruitment = true
}

// RecruitmentCleared reports if the "recruitment" edge to the Recruitment entity was cleared.
func (m *RecruitmentTagMutation) RecruitmentCleared() bool {
	return m.clearedrecruitment
}

// RecruitmentIDs returns the "recruitment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecruitmentID instead. It exists only for internal usage by the builders.
func (m *RecruitmentTagMutation) RecruitmentIDs() (ids []string) {
	if id := m.recruitment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecruitment resets all changes to the "recruitment" edge.
func (m *RecruitmentTagMutation) ResetRecruitment() {
	m.recruitment = nil
	m.clearedrecruitment = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *RecruitmentTagMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *RecruitmentTagMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *RecruitmentTagMutation) TagIDs() (ids []string) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *RecruitmentTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the RecruitmentTagMutation builder.
func (m *RecruitmentTagMutation) Where(ps ...predicate.RecruitmentTag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RecruitmentTagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RecruitmentTag).
func (m *RecruitmentTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecruitmentTagMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, recruitmenttag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recruitmenttag.FieldUpdatedAt)
	}
	if m.recruitment != nil {
		fields = append(fields, recruitmenttag.FieldRecruitmentID)
	}
	if m.tag != nil {
		fields = append(fields, recruitmenttag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecruitmentTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recruitmenttag.FieldCreatedAt:
		return m.CreatedAt()
	case recruitmenttag.FieldUpdatedAt:
		return m.UpdatedAt()
	case recruitmenttag.FieldRecruitmentID:
		return m.RecruitmentID()
	case recruitmenttag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecruitmentTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recruitmenttag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recruitmenttag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case recruitmenttag.FieldRecruitmentID:
		return m.OldRecruitmentID(ctx)
	case recruitmenttag.FieldTagID:
		return m.OldTagID(ctx)
	}
	return nil, fmt.Errorf("unknown RecruitmentTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecruitmentTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recruitmenttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recruitmenttag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case recruitmenttag.FieldRecruitmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecruitmentID(v)
		return nil
	case recruitmenttag.FieldTagID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown RecruitmentTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecruitmentTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecruitmentTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecruitmentTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecruitmentTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecruitmentTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecruitmentTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecruitmentTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecruitmentTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecruitmentTagMutation) ResetField(name string) error {
	switch name {
	case recruitmenttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recruitmenttag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case recruitmenttag.FieldRecruitmentID:
		m.ResetRecruitmentID()
		return nil
	case recruitmenttag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown RecruitmentTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecruitmentTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.recruitment != nil {
		edges = append(edges, recruitmenttag.EdgeRecruitment)
	}
	if m.tag != nil {
		edges = append(edges, recruitmenttag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecruitmentTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recruitmenttag.EdgeRecruitment:
		if id := m.recruitment; id != nil {
			return []ent.Value{*id}
		}
	case recruitmenttag.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecruitmentTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecruitmentTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecruitmentTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrecruitment {
		edges = append(edges, recruitmenttag.EdgeRecruitment)
	}
	if m.clearedtag {
		edges = append(edges, recruitmenttag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecruitmentTagMutation) EdgeCleared(name string) bool {
	switch name {
	case recruitmenttag.EdgeRecruitment:
		return m.clearedrecruitment
	case recruitmenttag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecruitmentTagMutation) ClearEdge(name string) error {
	switch name {
	case recruitmenttag.EdgeRecruitment:
		m.ClearRecruitment()
		return nil
	case recruitmenttag.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown RecruitmentTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecruitmentTagMutation) ResetEdge(name string) error {
	switch name {
	case recruitmenttag.EdgeRecruitment:
		m.ResetRecruitment()
		return nil
	case recruitmenttag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown RecruitmentTag edge %s", name)
}

// StockMutation represents an operation that mutates the Stock nodes in the graph.
type StockMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	recruitment        *string
	clearedrecruitment bool
	done               bool
	oldValue           func(context.Context) (*Stock, error)
	predicates         []predicate.Stock
}

var _ ent.Mutation = (*StockMutation)(nil)

// stockOption allows management of the mutation configuration using functional options.
type stockOption func(*StockMutation)

// newStockMutation creates new mutation for the Stock entity.
func newStockMutation(c config, op Op, opts ...stockOption) *StockMutation {
	m := &StockMutation{
		config:        c,
		op:            op,
		typ:           TypeStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockID sets the ID field of the mutation.
func withStockID(id string) stockOption {
	return func(m *StockMutation) {
		var (
			err   error
			once  sync.Once
			value *Stock
		)
		m.oldValue = func(ctx context.Context) (*Stock, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStock sets the old Stock of the mutation.
func withStock(node *Stock) stockOption {
	return func(m *StockMutation) {
		m.oldValue = func(context.Context) (*Stock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stock entities.
func (m *StockMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StockMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StockMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StockMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *StockMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StockMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StockMutation) ResetUserID() {
	m.user = nil
}

// SetRecruitmentID sets the "recruitment_id" field.
func (m *StockMutation) SetRecruitmentID(s string) {
	m.recruitment = &s
}

// RecruitmentID returns the value of the "recruitment_id" field in the mutation.
func (m *StockMutation) RecruitmentID() (r string, exists bool) {
	v := m.recruitment
	if v == nil {
		return
	}
	return *v, true
}

// OldRecruitmentID returns the old "recruitment_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldRecruitmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecruitmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecruitmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecruitmentID: %w", err)
	}
	return oldValue.RecruitmentID, nil
}

// ResetRecruitmentID resets all changes to the "recruitment_id" field.
func (m *StockMutation) ResetRecruitmentID() {
	m.recruitment = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *StockMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StockMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StockMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StockMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRecruitment clears the "recruitment" edge to the Recruitment entity.
func (m *StockMutation) ClearRecruitment() {
	m.clearedrecruitment = true
}

// RecruitmentCleared reports if the "recruitment" edge to the Recruitment entity was cleared.
func (m *StockMutation) RecruitmentCleared() bool {
	return m.clearedrecruitment
}

// RecruitmentIDs returns the "recruitment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecruitmentID instead. It exists only for internal usage by the builders.
func (m *StockMutation) RecruitmentIDs() (ids []string) {
	if id := m.recruitment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecruitment resets all changes to the "recruitment" edge.
func (m *StockMutation) ResetRecruitment() {
	m.recruitment = nil
	m.clearedrecruitment = false
}

// Where appends a list predicates to the StockMutation builder.
func (m *StockMutation) Where(ps ...predicate.Stock) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stock).
func (m *StockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, stock.FieldUserID)
	}
	if m.recruitment != nil {
		fields = append(fields, stock.FieldRecruitmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.CreatedAt()
	case stock.FieldUpdatedAt:
		return m.UpdatedAt()
	case stock.FieldUserID:
		return m.UserID()
	case stock.FieldRecruitmentID:
		return m.RecruitmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stock.FieldUserID:
		return m.OldUserID(ctx)
	case stock.FieldRecruitmentID:
		return m.OldRecruitmentID(ctx)
	}
	return nil, fmt.Errorf("unknown Stock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stock.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case stock.FieldRecruitmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecruitmentID(v)
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Stock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Stock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMutation) ResetField(name string) error {
	switch name {
	case stock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stock.FieldUserID:
		m.ResetUserID()
		return nil
	case stock.FieldRecruitmentID:
		m.ResetRecruitmentID()
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, stock.EdgeUser)
	}
	if m.recruitment != nil {
		edges = append(edges, stock.EdgeRecruitment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stock.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeRecruitment:
		if id := m.recruitment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, stock.EdgeUser)
	}
	if m.clearedrecruitment {
		edges = append(edges, stock.EdgeRecruitment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMutation) EdgeCleared(name string) bool {
	switch name {
	case stock.EdgeUser:
		return m.cleareduser
	case stock.EdgeRecruitment:
		return m.clearedrecruitment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMutation) ClearEdge(name string) error {
	switch name {
	case stock.EdgeUser:
		m.ClearUser()
		return nil
	case stock.EdgeRecruitment:
		m.ClearRecruitment()
		return nil
	}
	return fmt.Errorf("unknown Stock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMutation) ResetEdge(name string) error {
	switch name {
	case stock.EdgeUser:
		m.ResetUser()
		return nil
	case stock.EdgeRecruitment:
		m.ResetRecruitment()
		return nil
	}
	return fmt.Errorf("unknown Stock edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	clearedFields           map[string]struct{}
	recruitment_tags        map[string]struct{}
	removedrecruitment_tags map[string]struct{}
	clearedrecruitment_tags bool
	done                    bool
	oldValue                func(context.Context) (*Tag, error)
	predicates              []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id string) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddRecruitmentTagIDs adds the "recruitment_tags" edge to the RecruitmentTag entity by ids.
func (m *TagMutation) AddRecruitmentTagIDs(ids ...string) {
	if m.recruitment_tags == nil {
		m.recruitment_tags = make(map[string]struct{})
	}
	for i := range ids {
		m.recruitment_tags[ids[i]] = struct{}{}
	}
}

// ClearRecruitmentTags clears the "recruitment_tags" edge to the RecruitmentTag entity.
func (m *TagMutation) ClearRecruitmentTags() {
	m.clearedrecruitment_tags = true
}

// RecruitmentTagsCleared reports if the "recruitment_tags" edge to the RecruitmentTag entity was cleared.
func (m *TagMutation) RecruitmentTagsCleared() bool {
	return m.clearedrecruitment_tags
}

// RemoveRecruitmentTagIDs removes the "recruitment_tags" edge to the RecruitmentTag entity by IDs.
func (m *TagMutation) RemoveRecruitmentTagIDs(ids ...string) {
	if m.removedrecruitment_tags == nil {
		m.removedrecruitment_tags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.recruitment_tags, ids[i])
		m.removedrecruitment_tags[ids[i]] = struct{}{}
	}
}

// RemovedRecruitmentTags returns the removed IDs of the "recruitment_tags" edge to the RecruitmentTag entity.
func (m *TagMutation) RemovedRecruitmentTagsIDs() (ids []string) {
	for id := range m.removedrecruitment_tags {
		ids = append(ids, id)
	}
	return
}

// RecruitmentTagsIDs returns the "recruitment_tags" edge IDs in the mutation.
func (m *TagMutation) RecruitmentTagsIDs() (ids []string) {
	for id := range m.recruitment_tags {
		ids = append(ids, id)
	}
	return
}

// ResetRecruitmentTags resets all changes to the "recruitment_tags" edge.
func (m *TagMutation) ResetRecruitmentTags() {
	m.recruitment_tags = nil
	m.clearedrecruitment_tags = false
	m.removedrecruitment_tags = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.recruitment_tags != nil {
		edges = append(edges, tag.EdgeRecruitmentTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeRecruitmentTags:
		ids := make([]ent.Value, 0, len(m.recruitment_tags))
		for id := range m.recruitment_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecruitment_tags != nil {
		edges = append(edges, tag.EdgeRecruitmentTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeRecruitmentTags:
		ids := make([]ent.Value, 0, len(m.removedrecruitment_tags))
		for id := range m.removedrecruitment_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecruitment_tags {
		edges = append(edges, tag.EdgeRecruitmentTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeRecruitmentTags:
		return m.clearedrecruitment_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeRecruitmentTags:
		m.ResetRecruitmentTags()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *string
	created_at                          *time.Time
	updated_at                          *time.Time
	name                                *string
	email                               *string
	role                                *user.Role
	avatar                              *string
	introduction                        *string
	email_verification_status           *user.EmailVerificationStatus
	email_verification_token            *string
	email_verification_token_expires_at *time.Time
	password_digest                     *string
	last_sign_in_at                     *time.Time
	clearedFields                       map[string]struct{}
	recruitments                        map[string]struct{}
	removedrecruitments                 map[string]struct{}
	clearedrecruitments                 bool
	stocks                              map[string]struct{}
	removedstocks                       map[string]struct{}
	clearedstocks                       bool
	applicants                          map[string]struct{}
	removedapplicants                   map[string]struct{}
	clearedapplicants                   bool
	done                                bool
	oldValue                            func(context.Context) (*User, error)
	predicates                          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetIntroduction sets the "introduction" field.
func (m *UserMutation) SetIntroduction(s string) {
	m.introduction = &s
}

// Introduction returns the value of the "introduction" field in the mutation.
func (m *UserMutation) Introduction() (r string, exists bool) {
	v := m.introduction
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroduction returns the old "introduction" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIntroduction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntroduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntroduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroduction: %w", err)
	}
	return oldValue.Introduction, nil
}

// ClearIntroduction clears the value of the "introduction" field.
func (m *UserMutation) ClearIntroduction() {
	m.introduction = nil
	m.clearedFields[user.FieldIntroduction] = struct{}{}
}

// IntroductionCleared returns if the "introduction" field was cleared in this mutation.
func (m *UserMutation) IntroductionCleared() bool {
	_, ok := m.clearedFields[user.FieldIntroduction]
	return ok
}

// ResetIntroduction resets all changes to the "introduction" field.
func (m *UserMutation) ResetIntroduction() {
	m.introduction = nil
	delete(m.clearedFields, user.FieldIntroduction)
}

// SetEmailVerificationStatus sets the "email_verification_status" field.
func (m *UserMutation) SetEmailVerificationStatus(uvs user.EmailVerificationStatus) {
	m.email_verification_status = &uvs
}

// EmailVerificationStatus returns the value of the "email_verification_status" field in the mutation.
func (m *UserMutation) EmailVerificationStatus() (r user.EmailVerificationStatus, exists bool) {
	v := m.email_verification_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerificationStatus returns the old "email_verification_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerificationStatus(ctx context.Context) (v user.EmailVerificationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmailVerificationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmailVerificationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerificationStatus: %w", err)
	}
	return oldValue.EmailVerificationStatus, nil
}

// ResetEmailVerificationStatus resets all changes to the "email_verification_status" field.
func (m *UserMutation) ResetEmailVerificationStatus() {
	m.email_verification_status = nil
}

// SetEmailVerificationToken sets the "email_verification_token" field.
func (m *UserMutation) SetEmailVerificationToken(s string) {
	m.email_verification_token = &s
}

// EmailVerificationToken returns the value of the "email_verification_token" field in the mutation.
func (m *UserMutation) EmailVerificationToken() (r string, exists bool) {
	v := m.email_verification_token
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerificationToken returns the old "email_verification_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerificationToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmailVerificationToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmailVerificationToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerificationToken: %w", err)
	}
	return oldValue.EmailVerificationToken, nil
}

// ClearEmailVerificationToken clears the value of the "email_verification_token" field.
func (m *UserMutation) ClearEmailVerificationToken() {
	m.email_verification_token = nil
	m.clearedFields[user.FieldEmailVerificationToken] = struct{}{}
}

// EmailVerificationTokenCleared returns if the "email_verification_token" field was cleared in this mutation.
func (m *UserMutation) EmailVerificationTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerificationToken]
	return ok
}

// ResetEmailVerificationToken resets all changes to the "email_verification_token" field.
func (m *UserMutation) ResetEmailVerificationToken() {
	m.email_verification_token = nil
	delete(m.clearedFields, user.FieldEmailVerificationToken)
}

// SetEmailVerificationTokenExpiresAt sets the "email_verification_token_expires_at" field.
func (m *UserMutation) SetEmailVerificationTokenExpiresAt(t time.Time) {
	m.email_verification_token_expires_at = &t
}

// EmailVerificationTokenExpiresAt returns the value of the "email_verification_token_expires_at" field in the mutation.
func (m *UserMutation) EmailVerificationTokenExpiresAt() (r time.Time, exists bool) {
	v := m.email_verification_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerificationTokenExpiresAt returns the old "email_verification_token_expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerificationTokenExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmailVerificationTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmailVerificationTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerificationTokenExpiresAt: %w", err)
	}
	return oldValue.EmailVerificationTokenExpiresAt, nil
}

// ClearEmailVerificationTokenExpiresAt clears the value of the "email_verification_token_expires_at" field.
func (m *UserMutation) ClearEmailVerificationTokenExpiresAt() {
	m.email_verification_token_expires_at = nil
	m.clearedFields[user.FieldEmailVerificationTokenExpiresAt] = struct{}{}
}

// EmailVerificationTokenExpiresAtCleared returns if the "email_verification_token_expires_at" field was cleared in this mutation.
func (m *UserMutation) EmailVerificationTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerificationTokenExpiresAt]
	return ok
}

// ResetEmailVerificationTokenExpiresAt resets all changes to the "email_verification_token_expires_at" field.
func (m *UserMutation) ResetEmailVerificationTokenExpiresAt() {
	m.email_verification_token_expires_at = nil
	delete(m.clearedFields, user.FieldEmailVerificationTokenExpiresAt)
}

// SetPasswordDigest sets the "password_digest" field.
func (m *UserMutation) SetPasswordDigest(s string) {
	m.password_digest = &s
}

// PasswordDigest returns the value of the "password_digest" field in the mutation.
func (m *UserMutation) PasswordDigest() (r string, exists bool) {
	v := m.password_digest
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordDigest returns the old "password_digest" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordDigest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordDigest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordDigest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordDigest: %w", err)
	}
	return oldValue.PasswordDigest, nil
}

// ClearPasswordDigest clears the value of the "password_digest" field.
func (m *UserMutation) ClearPasswordDigest() {
	m.password_digest = nil
	m.clearedFields[user.FieldPasswordDigest] = struct{}{}
}

// PasswordDigestCleared returns if the "password_digest" field was cleared in this mutation.
func (m *UserMutation) PasswordDigestCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordDigest]
	return ok
}

// ResetPasswordDigest resets all changes to the "password_digest" field.
func (m *UserMutation) ResetPasswordDigest() {
	m.password_digest = nil
	delete(m.clearedFields, user.FieldPasswordDigest)
}

// SetLastSignInAt sets the "last_sign_in_at" field.
func (m *UserMutation) SetLastSignInAt(t time.Time) {
	m.last_sign_in_at = &t
}

// LastSignInAt returns the value of the "last_sign_in_at" field in the mutation.
func (m *UserMutation) LastSignInAt() (r time.Time, exists bool) {
	v := m.last_sign_in_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSignInAt returns the old "last_sign_in_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastSignInAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastSignInAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastSignInAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSignInAt: %w", err)
	}
	return oldValue.LastSignInAt, nil
}

// ClearLastSignInAt clears the value of the "last_sign_in_at" field.
func (m *UserMutation) ClearLastSignInAt() {
	m.last_sign_in_at = nil
	m.clearedFields[user.FieldLastSignInAt] = struct{}{}
}

// LastSignInAtCleared returns if the "last_sign_in_at" field was cleared in this mutation.
func (m *UserMutation) LastSignInAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastSignInAt]
	return ok
}

// ResetLastSignInAt resets all changes to the "last_sign_in_at" field.
func (m *UserMutation) ResetLastSignInAt() {
	m.last_sign_in_at = nil
	delete(m.clearedFields, user.FieldLastSignInAt)
}

// AddRecruitmentIDs adds the "recruitments" edge to the Recruitment entity by ids.
func (m *UserMutation) AddRecruitmentIDs(ids ...string) {
	if m.recruitments == nil {
		m.recruitments = make(map[string]struct{})
	}
	for i := range ids {
		m.recruitments[ids[i]] = struct{}{}
	}
}

// ClearRecruitments clears the "recruitments" edge to the Recruitment entity.
func (m *UserMutation) ClearRecruitments() {
	m.clearedrecruitments = true
}

// RecruitmentsCleared reports if the "recruitments" edge to the Recruitment entity was cleared.
func (m *UserMutation) RecruitmentsCleared() bool {
	return m.clearedrecruitments
}

// RemoveRecruitmentIDs removes the "recruitments" edge to the Recruitment entity by IDs.
func (m *UserMutation) RemoveRecruitmentIDs(ids ...string) {
	if m.removedrecruitments == nil {
		m.removedrecruitments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.recruitments, ids[i])
		m.removedrecruitments[ids[i]] = struct{}{}
	}
}

// RemovedRecruitments returns the removed IDs of the "recruitments" edge to the Recruitment entity.
func (m *UserMutation) RemovedRecruitmentsIDs() (ids []string) {
	for id := range m.removedrecruitments {
		ids = append(ids, id)
	}
	return
}

// RecruitmentsIDs returns the "recruitments" edge IDs in the mutation.
func (m *UserMutation) RecruitmentsIDs() (ids []string) {
	for id := range m.recruitments {
		ids = append(ids, id)
	}
	return
}

// ResetRecruitments resets all changes to the "recruitments" edge.
func (m *UserMutation) ResetRecruitments() {
	m.recruitments = nil
	m.clearedrecruitments = false
	m.removedrecruitments = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *UserMutation) AddStockIDs(ids ...string) {
	if m.stocks == nil {
		m.stocks = make(map[string]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *UserMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *UserMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *UserMutation) RemoveStockIDs(ids ...string) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *UserMutation) RemovedStocksIDs() (ids []string) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *UserMutation) StocksIDs() (ids []string) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *UserMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddApplicantIDs adds the "applicants" edge to the Applicant entity by ids.
func (m *UserMutation) AddApplicantIDs(ids ...string) {
	if m.applicants == nil {
		m.applicants = make(map[string]struct{})
	}
	for i := range ids {
		m.applicants[ids[i]] = struct{}{}
	}
}

// ClearApplicants clears the "applicants" edge to the Applicant entity.
func (m *UserMutation) ClearApplicants() {
	m.clearedapplicants = true
}

// ApplicantsCleared reports if the "applicants" edge to the Applicant entity was cleared.
func (m *UserMutation) ApplicantsCleared() bool {
	return m.clearedapplicants
}

// RemoveApplicantIDs removes the "applicants" edge to the Applicant entity by IDs.
func (m *UserMutation) RemoveApplicantIDs(ids ...string) {
	if m.removedapplicants == nil {
		m.removedapplicants = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.applicants, ids[i])
		m.removedapplicants[ids[i]] = struct{}{}
	}
}

// RemovedApplicants returns the removed IDs of the "applicants" edge to the Applicant entity.
func (m *UserMutation) RemovedApplicantsIDs() (ids []string) {
	for id := range m.removedapplicants {
		ids = append(ids, id)
	}
	return
}

// ApplicantsIDs returns the "applicants" edge IDs in the mutation.
func (m *UserMutation) ApplicantsIDs() (ids []string) {
	for id := range m.applicants {
		ids = append(ids, id)
	}
	return
}

// ResetApplicants resets all changes to the "applicants" edge.
func (m *UserMutation) ResetApplicants() {
	m.applicants = nil
	m.clearedapplicants = false
	m.removedapplicants = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.introduction != nil {
		fields = append(fields, user.FieldIntroduction)
	}
	if m.email_verification_status != nil {
		fields = append(fields, user.FieldEmailVerificationStatus)
	}
	if m.email_verification_token != nil {
		fields = append(fields, user.FieldEmailVerificationToken)
	}
	if m.email_verification_token_expires_at != nil {
		fields = append(fields, user.FieldEmailVerificationTokenExpiresAt)
	}
	if m.password_digest != nil {
		fields = append(fields, user.FieldPasswordDigest)
	}
	if m.last_sign_in_at != nil {
		fields = append(fields, user.FieldLastSignInAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldRole:
		return m.Role()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldIntroduction:
		return m.Introduction()
	case user.FieldEmailVerificationStatus:
		return m.EmailVerificationStatus()
	case user.FieldEmailVerificationToken:
		return m.EmailVerificationToken()
	case user.FieldEmailVerificationTokenExpiresAt:
		return m.EmailVerificationTokenExpiresAt()
	case user.FieldPasswordDigest:
		return m.PasswordDigest()
	case user.FieldLastSignInAt:
		return m.LastSignInAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldIntroduction:
		return m.OldIntroduction(ctx)
	case user.FieldEmailVerificationStatus:
		return m.OldEmailVerificationStatus(ctx)
	case user.FieldEmailVerificationToken:
		return m.OldEmailVerificationToken(ctx)
	case user.FieldEmailVerificationTokenExpiresAt:
		return m.OldEmailVerificationTokenExpiresAt(ctx)
	case user.FieldPasswordDigest:
		return m.OldPasswordDigest(ctx)
	case user.FieldLastSignInAt:
		return m.OldLastSignInAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldIntroduction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroduction(v)
		return nil
	case user.FieldEmailVerificationStatus:
		v, ok := value.(user.EmailVerificationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerificationStatus(v)
		return nil
	case user.FieldEmailVerificationToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerificationToken(v)
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerificationTokenExpiresAt(v)
		return nil
	case user.FieldPasswordDigest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordDigest(v)
		return nil
	case user.FieldLastSignInAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSignInAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldIntroduction) {
		fields = append(fields, user.FieldIntroduction)
	}
	if m.FieldCleared(user.FieldEmailVerificationToken) {
		fields = append(fields, user.FieldEmailVerificationToken)
	}
	if m.FieldCleared(user.FieldEmailVerificationTokenExpiresAt) {
		fields = append(fields, user.FieldEmailVerificationTokenExpiresAt)
	}
	if m.FieldCleared(user.FieldPasswordDigest) {
		fields = append(fields, user.FieldPasswordDigest)
	}
	if m.FieldCleared(user.FieldLastSignInAt) {
		fields = append(fields, user.FieldLastSignInAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldIntroduction:
		m.ClearIntroduction()
		return nil
	case user.FieldEmailVerificationToken:
		m.ClearEmailVerificationToken()
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		m.ClearEmailVerificationTokenExpiresAt()
		return nil
	case user.FieldPasswordDigest:
		m.ClearPasswordDigest()
		return nil
	case user.FieldLastSignInAt:
		m.ClearLastSignInAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldIntroduction:
		m.ResetIntroduction()
		return nil
	case user.FieldEmailVerificationStatus:
		m.ResetEmailVerificationStatus()
		return nil
	case user.FieldEmailVerificationToken:
		m.ResetEmailVerificationToken()
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		m.ResetEmailVerificationTokenExpiresAt()
		return nil
	case user.FieldPasswordDigest:
		m.ResetPasswordDigest()
		return nil
	case user.FieldLastSignInAt:
		m.ResetLastSignInAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.recruitments != nil {
		edges = append(edges, user.EdgeRecruitments)
	}
	if m.stocks != nil {
		edges = append(edges, user.EdgeStocks)
	}
	if m.applicants != nil {
		edges = append(edges, user.EdgeApplicants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRecruitments:
		ids := make([]ent.Value, 0, len(m.recruitments))
		for id := range m.recruitments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApplicants:
		ids := make([]ent.Value, 0, len(m.applicants))
		for id := range m.applicants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrecruitments != nil {
		edges = append(edges, user.EdgeRecruitments)
	}
	if m.removedstocks != nil {
		edges = append(edges, user.EdgeStocks)
	}
	if m.removedapplicants != nil {
		edges = append(edges, user.EdgeApplicants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRecruitments:
		ids := make([]ent.Value, 0, len(m.removedrecruitments))
		for id := range m.removedrecruitments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApplicants:
		ids := make([]ent.Value, 0, len(m.removedapplicants))
		for id := range m.removedapplicants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrecruitments {
		edges = append(edges, user.EdgeRecruitments)
	}
	if m.clearedstocks {
		edges = append(edges, user.EdgeStocks)
	}
	if m.clearedapplicants {
		edges = append(edges, user.EdgeApplicants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRecruitments:
		return m.clearedrecruitments
	case user.EdgeStocks:
		return m.clearedstocks
	case user.EdgeApplicants:
		return m.clearedapplicants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRecruitments:
		m.ResetRecruitments()
		return nil
	case user.EdgeStocks:
		m.ResetStocks()
		return nil
	case user.EdgeApplicants:
		m.ResetApplicants()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
